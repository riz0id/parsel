
==================== Final STG: ====================
2022-10-01 02:03:01.219126 UTC

whitespace2 :: Parse Char
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Chr! [' '#];

whitespace3 :: Addr#
[GblId, Unf=OtherCon []] =
    "\t\r\n"#;

Rec {
whitespace_go [Occ=LoopBreaker] :: Addr# -> Parse Char -> Parse Char
[GblId, Arity=2, Str=<L><ML>, Unf=OtherCon []] =
    {} \r [addr z]
        case indexCharOffAddr# [addr 0#] of ch [Occ=Once1] {
          __DEFAULT ->
              let {
                sat [Occ=Once1] :: Parse Char
                [LclId] =
                    {z, addr} \u []
                        case plusAddr# [addr 1#] of sat [Occ=Once1] {
                        __DEFAULT -> whitespace_go sat z;
                        }; } in
              let {
                sat [Occ=Once1] :: Parse Char
                [LclId] =
                    CCCS Chr! [ch];
              } in  Alt [sat sat];
          '\NUL'# -> z;
        };
end Rec }

whitespace1 :: Parse Char
[GblId] =
    {} \u [] whitespace_go whitespace3 whitespace2;

whitespace4 :: Char -> ()
[GblId, Arity=1, Str=<A>, Unf=OtherCon []] =
    {} \r [ds] () [];

whitespace :: Parse ()
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Map! [whitespace4 whitespace1];

n2 :: Parse Char
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Chr! ['a'#];

Rec {
go2 :: Int# -> Parse Char
[GblId, Arity=1, Str=<L>, Unf=OtherCon []] =
    {} \r [x]
        case ># [x 122#] of {
          __DEFAULT ->
              let {
                sat [Occ=Once1] :: Parse Char
                [LclId] =
                    {x} \u [] case +# [x 1#] of sat [Occ=Once1] { __DEFAULT -> go2 sat; };
              } in 
                case chr# [x] of sat [Occ=Once1] {
                __DEFAULT ->
                let {
                  sat [Occ=Once1] :: Parse Char
                  [LclId] =
                      CCCS Chr! [sat];
                } in  Alt [sat sat];
                };
          1# -> n2;
        };
end Rec }

lower [InlPrag=INLINE (sat-args=0) CONLIKE] :: Parse Char
[GblId] =
    {} \u [] go2 98#;

alpha1 :: Parse Char
[GblId] =
    {} \u [] go2 98#;

n1 :: Parse Char
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Chr! ['A'#];

Rec {
go1 :: Int# -> Parse Char
[GblId, Arity=1, Str=<L>, Unf=OtherCon []] =
    {} \r [x]
        case ># [x 90#] of {
          __DEFAULT ->
              let {
                sat [Occ=Once1] :: Parse Char
                [LclId] =
                    {x} \u [] case +# [x 1#] of sat [Occ=Once1] { __DEFAULT -> go1 sat; };
              } in 
                case chr# [x] of sat [Occ=Once1] {
                __DEFAULT ->
                let {
                  sat [Occ=Once1] :: Parse Char
                  [LclId] =
                      CCCS Chr! [sat];
                } in  Alt [sat sat];
                };
          1# -> n1;
        };
end Rec }

upper [InlPrag=INLINE (sat-args=0) CONLIKE] :: Parse Char
[GblId] =
    {} \u [] go1 66#;

alpha2 :: Parse Char
[GblId] =
    {} \u [] go1 66#;

alpha [InlPrag=INLINE (sat-args=0) CONLIKE] :: Parse Char
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Alt! [alpha1 alpha2];

alphaNum1 :: Parse Char
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Alt! [alpha1 alpha2];

n :: Parse Char
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Chr! ['0'#];

Rec {
go3 :: Int# -> Parse Char
[GblId, Arity=1, Str=<L>, Unf=OtherCon []] =
    {} \r [x]
        case ># [x 57#] of {
          __DEFAULT ->
              let {
                sat [Occ=Once1] :: Parse Char
                [LclId] =
                    {x} \u [] case +# [x 1#] of sat [Occ=Once1] { __DEFAULT -> go3 sat; };
              } in 
                case chr# [x] of sat [Occ=Once1] {
                __DEFAULT ->
                let {
                  sat [Occ=Once1] :: Parse Char
                  [LclId] =
                      CCCS Chr! [sat];
                } in  Alt [sat sat];
                };
          1# -> n;
        };
end Rec }

digit [InlPrag=INLINE (sat-args=0) CONLIKE] :: Parse Char
[GblId] =
    {} \u [] go3 49#;

alphaNum2 :: Parse Char
[GblId] =
    {} \u [] go3 49#;

alphaNum [InlPrag=INLINE (sat-args=0) CONLIKE] :: Parse Char
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Alt! [alphaNum1 alphaNum2];

$trModule2 :: Addr#
[GblId, Unf=OtherCon []] =
    "Text.Parsel"#;

$trModule1 :: TrName
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE TrNameS! [$trModule2];

$trModule4 :: Addr#
[GblId, Unf=OtherCon []] =
    "parsel-parse-0.0.0-inplace"#;

$trModule3 :: TrName
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE TrNameS! [$trModule4];

$trModule :: Module
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Module! [$trModule3 $trModule1];

lvl4 :: forall {a}. (a, [a]) -> NonEmpty a
[GblId, Arity=1, Str=<LP(ML,ML)>, Cpr=1, Unf=OtherCon []] =
    {} \r [p]
        let {
          sat [Occ=Once1] :: [a]
          [LclId] =
              {p} \u [] case p of { (,) _ [Occ=Dead] y [Occ=Once1] -> y; }; } in
        let {
          sat [Occ=Once1] :: a
          [LclId] =
              {p} \u [] case p of { (,) x [Occ=Once1] _ [Occ=Dead] -> x; };
        } in  :| [sat sat];

lvl3 :: forall {a}. (a, [a]) -> [a]
[GblId, Arity=1, Str=<LP(ML,ML)>, Cpr=2, Unf=OtherCon []] =
    {} \r [p]
        let {
          sat [Occ=Once1] :: [a]
          [LclId] =
              {p} \u [] case p of { (,) _ [Occ=Dead] y [Occ=Once1] -> y; }; } in
        let {
          sat [Occ=Once1] :: a
          [LclId] =
              {p} \u [] case p of { (,) x [Occ=Once1] _ [Occ=Dead] -> x; };
        } in  : [sat sat];

lvl1 :: forall {a}. () -> [a]
[GblId, Arity=1, Str=<A>, Unf=OtherCon []] =
    {} \r [ds] [] [];

lvl2 :: forall {a}. Parse [a]
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Map! [lvl1 $WEps];

Rec {
star [InlPrag=[2] CONLIKE] :: forall a. Parse a -> Parse [a]
[GblId, Arity=1, Str=<L>, Cpr=7, Unf=OtherCon []] =
    {} \r [w]
        case $wstar w of { (#,#) ww1 [Occ=Once1] ww2 [Occ=Once1] -> Alt [ww1 ww2]; };

$wstar [InlPrag=INLINE[2], Occ=LoopBreaker]
  :: forall {a}. Parse a -> (# Parse [a], Parse [a] #)
[GblId, Arity=1, Str=<L>, Unf=OtherCon []] =
    {} \r [w]
        let {
          sat [Occ=Once1] :: Parse [a]
          [LclId] =
              {w} \u [] star w; } in
        let {
          sat [Occ=Once1] :: Parse (a, [a])
          [LclId] =
              CCCS Seq! [w sat]; } in
        let {
          sat [Occ=Once1] :: Parse [a]
          [LclId] =
              CCCS Map! [lvl3 sat];
        } in  (#,#) [sat lvl2];
end Rec }

star1 [InlPrag=INLINE (sat-args=1) CONLIKE]
  :: forall a. Parse a -> Parse (NonEmpty a)
[GblId, Arity=1, Str=<L>, Unf=OtherCon []] =
    {} \r [eta]
        let {
          sat [Occ=Once1] :: Parse [a]
          [LclId] =
              {eta} \u [] star eta; } in
        let {
          sat [Occ=Once1] :: Parse (a, [a])
          [LclId] =
              CCCS Seq! [eta sat];
        } in  Map [lvl4 sat];

string [InlPrag=INLINE (sat-args=0) CONLIKE] :: String -> Parse String
[GblId, Arity=1, Str=<L>, Cpr=4, Unf=OtherCon []] =
    {} \r [ds] $WStr ds;

char [InlPrag=INLINE (sat-args=0) CONLIKE] :: Char -> Parse Char
[GblId, Arity=1, Str=<SL>, Cpr=3, Unf=OtherCon []] =
    {} \r [ds] $WChr ds;

lvl :: forall {b} {c}. (c, b) -> c
[GblId, Arity=1, Str=<1P(1L,A)>, Unf=OtherCon []] =
    {} \r [p] case p of { (,) x [Occ=Once1] _ [Occ=Dead] -> x; };

between [InlPrag=INLINE (sat-args=3) CONLIKE]
  :: forall a b c. Parse a -> Parse b -> Parse c -> Parse c
[GblId, Arity=3, Str=<L><L><L>, Unf=OtherCon []] =
    {} \r [eta eta1 eta2]
        let {
          sat [Occ=Once1] :: Parse (c -> c)
          [LclId] =
              CCCS Map! [$fApplicativeParse1 eta]; } in
        let {
          sat [Occ=Once1] :: Parse (c -> c, c)
          [LclId] =
              CCCS Seq! [sat eta2]; } in
        let {
          sat [Occ=Once1] :: Parse c
          [LclId] =
              CCCS Map! [$fApplicativeParse2 sat]; } in
        let {
          sat [Occ=Once1] :: Parse (c, b)
          [LclId] =
              CCCS Seq! [sat eta1];
        } in  Map [lvl sat];


==================== Final STG: ====================
2022-10-01 02:03:01.368137 UTC

whitespace2 :: Parse Char
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Chr! [' '#];

whitespace3 :: Addr#
[GblId, Unf=OtherCon []] =
    "\t\r\n"#;

Rec {
whitespace_go [Occ=LoopBreaker] :: Addr# -> Parse Char -> Parse Char
[GblId, Arity=2, Str=<L><ML>, Unf=OtherCon []] =
    {} \r [addr z]
        case indexCharOffAddr# [addr 0#] of ch [Occ=Once1] {
          __DEFAULT ->
              let {
                sat [Occ=Once1] :: Parse Char
                [LclId] =
                    {z, addr} \u []
                        case plusAddr# [addr 1#] of sat [Occ=Once1] {
                        __DEFAULT -> whitespace_go sat z;
                        }; } in
              let {
                sat [Occ=Once1] :: Parse Char
                [LclId] =
                    CCCS Chr! [ch];
              } in  Alt [sat sat];
          '\NUL'# -> z;
        };
end Rec }

whitespace1 :: Parse Char
[GblId] =
    {} \u [] whitespace_go whitespace3 whitespace2;

whitespace4 :: Char -> ()
[GblId, Arity=1, Str=<A>, Unf=OtherCon []] =
    {} \r [ds] () [];

whitespace :: Parse ()
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Map! [whitespace4 whitespace1];

n2 :: Parse Char
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Chr! ['a'#];

Rec {
go2 :: Int# -> Parse Char
[GblId, Arity=1, Str=<L>, Unf=OtherCon []] =
    {} \r [x]
        case ># [x 122#] of {
          __DEFAULT ->
              let {
                sat [Occ=Once1] :: Parse Char
                [LclId] =
                    {x} \u [] case +# [x 1#] of sat [Occ=Once1] { __DEFAULT -> go2 sat; };
              } in 
                case chr# [x] of sat [Occ=Once1] {
                __DEFAULT ->
                let {
                  sat [Occ=Once1] :: Parse Char
                  [LclId] =
                      CCCS Chr! [sat];
                } in  Alt [sat sat];
                };
          1# -> n2;
        };
end Rec }

lower [InlPrag=INLINE (sat-args=0) CONLIKE] :: Parse Char
[GblId] =
    {} \u [] go2 98#;

alpha1 :: Parse Char
[GblId] =
    {} \u [] go2 98#;

n1 :: Parse Char
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Chr! ['A'#];

Rec {
go1 :: Int# -> Parse Char
[GblId, Arity=1, Str=<L>, Unf=OtherCon []] =
    {} \r [x]
        case ># [x 90#] of {
          __DEFAULT ->
              let {
                sat [Occ=Once1] :: Parse Char
                [LclId] =
                    {x} \u [] case +# [x 1#] of sat [Occ=Once1] { __DEFAULT -> go1 sat; };
              } in 
                case chr# [x] of sat [Occ=Once1] {
                __DEFAULT ->
                let {
                  sat [Occ=Once1] :: Parse Char
                  [LclId] =
                      CCCS Chr! [sat];
                } in  Alt [sat sat];
                };
          1# -> n1;
        };
end Rec }

upper [InlPrag=INLINE (sat-args=0) CONLIKE] :: Parse Char
[GblId] =
    {} \u [] go1 66#;

alpha2 :: Parse Char
[GblId] =
    {} \u [] go1 66#;

alpha [InlPrag=INLINE (sat-args=0) CONLIKE] :: Parse Char
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Alt! [alpha1 alpha2];

alphaNum1 :: Parse Char
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Alt! [alpha1 alpha2];

n :: Parse Char
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Chr! ['0'#];

Rec {
go3 :: Int# -> Parse Char
[GblId, Arity=1, Str=<L>, Unf=OtherCon []] =
    {} \r [x]
        case ># [x 57#] of {
          __DEFAULT ->
              let {
                sat [Occ=Once1] :: Parse Char
                [LclId] =
                    {x} \u [] case +# [x 1#] of sat [Occ=Once1] { __DEFAULT -> go3 sat; };
              } in 
                case chr# [x] of sat [Occ=Once1] {
                __DEFAULT ->
                let {
                  sat [Occ=Once1] :: Parse Char
                  [LclId] =
                      CCCS Chr! [sat];
                } in  Alt [sat sat];
                };
          1# -> n;
        };
end Rec }

digit [InlPrag=INLINE (sat-args=0) CONLIKE] :: Parse Char
[GblId] =
    {} \u [] go3 49#;

alphaNum2 :: Parse Char
[GblId] =
    {} \u [] go3 49#;

alphaNum [InlPrag=INLINE (sat-args=0) CONLIKE] :: Parse Char
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Alt! [alphaNum1 alphaNum2];

$trModule2 :: Addr#
[GblId, Unf=OtherCon []] =
    "Text.Parsel"#;

$trModule1 :: TrName
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE TrNameS! [$trModule2];

$trModule4 :: Addr#
[GblId, Unf=OtherCon []] =
    "parsel-parse-0.0.0-inplace"#;

$trModule3 :: TrName
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE TrNameS! [$trModule4];

$trModule :: Module
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Module! [$trModule3 $trModule1];

lvl4 :: forall {a}. (a, [a]) -> NonEmpty a
[GblId, Arity=1, Str=<LP(ML,ML)>, Cpr=1, Unf=OtherCon []] =
    {} \r [p]
        let {
          sat [Occ=Once1] :: [a]
          [LclId] =
              {p} \u [] case p of { (,) _ [Occ=Dead] y [Occ=Once1] -> y; }; } in
        let {
          sat [Occ=Once1] :: a
          [LclId] =
              {p} \u [] case p of { (,) x [Occ=Once1] _ [Occ=Dead] -> x; };
        } in  :| [sat sat];

lvl3 :: forall {a}. (a, [a]) -> [a]
[GblId, Arity=1, Str=<LP(ML,ML)>, Cpr=2, Unf=OtherCon []] =
    {} \r [p]
        let {
          sat [Occ=Once1] :: [a]
          [LclId] =
              {p} \u [] case p of { (,) _ [Occ=Dead] y [Occ=Once1] -> y; }; } in
        let {
          sat [Occ=Once1] :: a
          [LclId] =
              {p} \u [] case p of { (,) x [Occ=Once1] _ [Occ=Dead] -> x; };
        } in  : [sat sat];

lvl1 :: forall {a}. () -> [a]
[GblId, Arity=1, Str=<A>, Unf=OtherCon []] =
    {} \r [ds] [] [];

lvl2 :: forall {a}. Parse [a]
[GblId, Unf=OtherCon []] =
    CCS_DONT_CARE Map! [lvl1 $WEps];

Rec {
star [InlPrag=[2] CONLIKE] :: forall a. Parse a -> Parse [a]
[GblId, Arity=1, Str=<L>, Cpr=7, Unf=OtherCon []] =
    {} \r [w]
        case $wstar w of { (#,#) ww1 [Occ=Once1] ww2 [Occ=Once1] -> Alt [ww1 ww2]; };

$wstar [InlPrag=INLINE[2], Occ=LoopBreaker]
  :: forall {a}. Parse a -> (# Parse [a], Parse [a] #)
[GblId, Arity=1, Str=<L>, Unf=OtherCon []] =
    {} \r [w]
        let {
          sat [Occ=Once1] :: Parse [a]
          [LclId] =
              {w} \u [] star w; } in
        let {
          sat [Occ=Once1] :: Parse (a, [a])
          [LclId] =
              CCCS Seq! [w sat]; } in
        let {
          sat [Occ=Once1] :: Parse [a]
          [LclId] =
              CCCS Map! [lvl3 sat];
        } in  (#,#) [sat lvl2];
end Rec }

star1 [InlPrag=INLINE (sat-args=1) CONLIKE]
  :: forall a. Parse a -> Parse (NonEmpty a)
[GblId, Arity=1, Str=<L>, Unf=OtherCon []] =
    {} \r [eta]
        let {
          sat [Occ=Once1] :: Parse [a]
          [LclId] =
              {eta} \u [] star eta; } in
        let {
          sat [Occ=Once1] :: Parse (a, [a])
          [LclId] =
              CCCS Seq! [eta sat];
        } in  Map [lvl4 sat];

string [InlPrag=INLINE (sat-args=0) CONLIKE] :: String -> Parse String
[GblId, Arity=1, Str=<L>, Cpr=4, Unf=OtherCon []] =
    {} \r [ds] $WStr ds;

char [InlPrag=INLINE (sat-args=0) CONLIKE] :: Char -> Parse Char
[GblId, Arity=1, Str=<SL>, Cpr=3, Unf=OtherCon []] =
    {} \r [ds] $WChr ds;

lvl :: forall {b} {c}. (c, b) -> c
[GblId, Arity=1, Str=<1P(1L,A)>, Unf=OtherCon []] =
    {} \r [p] case p of { (,) x [Occ=Once1] _ [Occ=Dead] -> x; };

between [InlPrag=INLINE (sat-args=3) CONLIKE]
  :: forall a b c. Parse a -> Parse b -> Parse c -> Parse c
[GblId, Arity=3, Str=<L><L><L>, Unf=OtherCon []] =
    {} \r [eta eta1 eta2]
        let {
          sat [Occ=Once1] :: Parse (c -> c)
          [LclId] =
              CCCS Map! [$fApplicativeParse1 eta]; } in
        let {
          sat [Occ=Once1] :: Parse (c -> c, c)
          [LclId] =
              CCCS Seq! [sat eta2]; } in
        let {
          sat [Occ=Once1] :: Parse c
          [LclId] =
              CCCS Map! [$fApplicativeParse2 sat]; } in
        let {
          sat [Occ=Once1] :: Parse (c, b)
          [LclId] =
              CCCS Seq! [sat eta1];
        } in  Map [lvl sat];

